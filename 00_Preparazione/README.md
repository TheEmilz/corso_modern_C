# Modulo 00 - Preparazione: Fondamenti di Algoritmi e Strutture Dati

## Introduzione

Questo modulo preparatorio √® progettato per fornire le basi di pensiero computazionale, algoritmi e strutture dati **prima** di iniziare lo studio del linguaggio C. L'obiettivo √® sviluppare una solida comprensione dei concetti fondamentali che rendono pi√π naturale e consapevole l'apprendimento della programmazione in C.

## üéØ Obiettivi del Modulo

Alla fine di questo modulo sarai in grado di:
- Comprendere cos'√® un algoritmo e come ragionare in modo algoritmico
- Analizzare la complessit√† e l'efficienza degli algoritmi
- Conoscere le strutture dati fondamentali e quando usarle
- Applicare tecniche di debugging sistematico
- Risolvere problemi con approccio progressivo e metodico

## üìö Struttura del Modulo

### [1. Pensiero Computazionale](01_pensiero_computazionale.md)
- Cos'√® un algoritmo
- Decomposizione del problema
- Riconoscimento di pattern
- Astrazione e generalizzazione
- **Debug**: Come ragionare su un problema prima di scrivere codice

### [2. Complessit√† e Analisi degli Algoritmi](02_complessita.md)
- Notazione Big-O
- Tempo di esecuzione e spazio in memoria
- Casi migliore, medio e peggiore
- Confronto tra algoritmi
- **Debug**: Identificare colli di bottiglia nelle performance

### [3. Algoritmi di Ricerca](03_ricerca.md)
- Ricerca lineare (sequenziale)
- Ricerca binaria
- Ricerca per interpolazione
- Esempi pratici e visualizzazioni
- **Debug passo-passo**: Tracciare l'esecuzione degli algoritmi

### [4. Algoritmi di Ordinamento](04_ordinamento.md)
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Confronto e scelta dell'algoritmo giusto
- **Debug**: Trovare errori negli algoritmi di ordinamento

### [5. Strutture Dati: Array e Liste](05_array_liste.md)
- Array statici vs dinamici
- Liste concatenate (singly e doubly linked)
- Operazioni: inserimento, rimozione, ricerca
- Vantaggi e svantaggi
- **Debug**: Problemi comuni con puntatori e memoria

### [6. Strutture Dati: Stack e Queue](06_stack_queue.md)
- Stack (LIFO - Last In First Out)
- Queue (FIFO - First In First Out)
- Implementazioni e applicazioni pratiche
- **Debug**: Gestione dello stack overflow e underflow

### [7. Strutture Dati: Alberi](07_alberi.md)
- Alberi binari
- Alberi binari di ricerca (BST)
- Bilanciamento degli alberi
- Attraversamenti (in-order, pre-order, post-order)
- **Debug**: Visualizzare strutture ad albero

### [8. Strutture Dati: Hash Table](08_hash_table.md)
- Funzioni hash
- Gestione delle collisioni
- Tabelle hash in pratica
- **Debug**: Problemi di collisione e performance

### [9. Ricorsione](09_ricorsione.md)
- Cos'√® la ricorsione
- Caso base e caso ricorsivo
- Stack delle chiamate
- Ricorsione vs iterazione
- **Debug**: Tracciare chiamate ricorsive e stack overflow

### [10. Metodologia di Debug](10_debugging.md)
- Approccio sistematico al debugging
- Tecniche di debugging
- Strumenti mentali per il problem solving
- Casi di studio con soluzioni passo-passo
- Errori comuni e come evitarli

### [11. Esercizi Progressivi](11_esercizi.md)
- Esercizi di livello crescente
- Soluzioni commentate passo-passo
- Sfide algoritmiche con debug guidato

## üí° Approccio Didattico

Questo modulo segue una **didattica progressiva per livelli**:

### Livello 1: Concetti Base (Lezioni 1-3)
- Introduzione gentile ai concetti
- Esempi semplici e intuitivi
- Visualizzazioni e diagrammi
- Focus sul "perch√©" prima del "come"

### Livello 2: Applicazione Pratica (Lezioni 4-6)
- Implementazione dei concetti
- Pseudocodice prima del codice reale
- Analisi di casi concreti
- Esercizi guidati con debug

### Livello 3: Approfondimento (Lezioni 7-9)
- Strutture dati complesse
- Ottimizzazione e trade-off
- Problemi del mondo reale
- Debug avanzato

### Livello 4: Maestria (Lezioni 10-11)
- Sintesi delle conoscenze
- Metodologie professionali
- Progetti completi
- Autonomia nel debug

## üîß Come Usare Questo Modulo

1. **Segui l'ordine**: Le lezioni sono progettate in sequenza progressiva
2. **Fai gli esercizi**: Ogni concetto ha esercizi pratici
3. **Debug attivo**: Non limitarti a leggere, prova a debuggare gli esempi
4. **Visualizza**: Disegna diagrammi e traccia l'esecuzione degli algoritmi
5. **Sperimenta**: Modifica gli esempi e osserva cosa succede

## üìù Nota Importante

Questo modulo **non usa ancora C**! Gli algoritmi e le strutture dati sono presentati con:
- **Pseudocodice**: Notazione indipendente dal linguaggio
- **Diagrammi**: Visualizzazioni grafiche
- **Descrizioni**: Spiegazioni in linguaggio naturale
- **Esempi pratici**: Situazioni del mondo reale

Una volta completato questo modulo, avrai le basi concettuali per affrontare lo studio del C con maggiore consapevolezza e comprensione.

## üéì Perch√© Questo Modulo √® Importante

Molti studenti trovano difficile imparare C perch√© cercano di apprendere **simultaneamente**:
- La sintassi del linguaggio
- I concetti di programmazione
- Gli algoritmi
- Le strutture dati
- Il pensiero computazionale

Questo modulo **separa** queste competenze, permettendoti di costruire una base solida di pensiero algoritmico **prima** di confrontarti con la sintassi del C.

## Prossimi Passi

Dopo aver completato questo modulo, sarai pronto per iniziare il [Modulo 01 - Introduzione al C](../01_Introduzione/README.md) con una comprensione profonda di:
- Come affrontare i problemi in modo algoritmico
- Quali strutture dati usare in diversi scenari
- Come debuggare il codice sistematicamente
- Come ottimizzare soluzioni

---

[Torna al Sommario](../README.md) | [Inizia: Pensiero Computazionale ‚Üí](01_pensiero_computazionale.md)
